import{get_request_store as e,with_request_store as t}from"@sveltejs/kit/internal/server";import{parse as r}from"devalue";import{error as n,json as s}from"@sveltejs/kit";import{a as o,s as i,c as a}from"./chunks/shared.js";import"clsx";import{r as c}from"./chunks/utils2.js";import{B as u}from"./chunks/false.js";import{b as l,c as f,p as d}from"./chunks/environment.js";function p(t,r){if(!r)return e=>{void 0!==e&&n(400,"Bad Request")};if("unchecked"===t)return e=>e;if("~standard"in t)return async r=>{const{event:s,state:o}=e(),i=t["~standard"].validate,a=await i(r);return a.issues&&n(400,await o.handleValidationError({issues:a.issues,event:s})),a.value};throw new Error('Invalid validator passed to remote function. Expected "unchecked" or a Standard Schema (https://standardschema.dev)')}async function m(e,t,r,n){await 0;const s=y(e,r);return s[o(t,r.transport)]??=n()}async function h(e,r,n,s,o,i){const a={event:{...e,setHeaders:()=>{throw new Error("setHeaders is not allowed in remote functions")},cookies:{...e.cookies,set:(t,r,s)=>{if(!n)throw new Error("Cannot set cookies in `query` or `prerender` functions");if(s.path&&!s.path.startsWith("/"))throw new Error("Cookies set in remote functions must have an absolute path");return e.cookies.set(t,r,s)},delete:(t,r)=>{if(!n)throw new Error("Cannot delete cookies in `query` or `prerender` functions");if(r.path&&!r.path.startsWith("/"))throw new Error("Cookies deleted in remote functions must have an absolute path");return e.cookies.delete(t,r)}}},state:{...r,is_in_remote_function:!0}},c=await t(a,()=>o(s));return t(a,()=>i(c))}function y(t,r=e().state){let n=r.remote_data?.get(t);return void 0===n&&(n={},(r.remote_data??=new Map).set(t,n)),n}function v(t,r){const n=r??t,s=p(t,r),o={type:"command",id:"",name:""},i=t=>{const{event:i,state:a}=e();if(a.is_endpoint_request){if(!["POST","PUT","PATCH","DELETE"].includes(i.request.method))throw new Error(`Cannot call a command (\`${o.name}(${r?"...":""})\`) from a ${i.request.method} handler`)}else if(!i.isRemoteRequest)throw new Error(`Cannot call a command (\`${o.name}(${r?"...":""})\`) during server-side rendering`);a.refreshes??={};const c=Promise.resolve(h(i,a,!0,t,s,n));return c.updates=()=>{throw new Error(`Cannot call '${o.name}(...).updates(...)' on the server`)},c};return Object.defineProperty(i,"__",{value:o}),Object.defineProperty(i,"pending",{get:()=>0}),i}const g=c??(e=>e());function w(e,t,r){return t.startsWith("n:")?(t=t.slice(2),r=""===r?void 0:parseFloat(r)):t.startsWith("b:")&&(t=t.slice(2),r="on"===r),j(e,function(e){if(!b.test(e))throw new Error(`Invalid path ${e}`);return e.split(/\.|\[|\]/).filter(Boolean)}(t),r)}const b=/^[a-zA-Z_$]\w*(\.[a-zA-Z_$]\w*|\[\d+\])*$/;function j(e,t,r){const n=Object.assign(Object.create(null),e);let s=n;for(let o=0;o<t.length-1;o+=1){const e=t[o],r=/^\d+$/.test(t[o+1]),n=e in s,i=s[e];if(n&&r!==Array.isArray(i))throw new Error(`Invalid array key ${t[o+1]}`);s[e]=r?n?[...i]:[]:Object.assign(Object.create(null),i),s=s[e]}return s[t[t.length-1]]=r,n}function O(e,t,r,n,s,o=[]){const i=P(o),a=()=>(r(i),g(()=>function(e,t){let r=e;for(const n of t){if(null==r||"object"!=typeof r)return r;r=r[n]}return r}(t(),o)));return new Proxy(e,{get(e,i){if("symbol"==typeof i)return e[i];if(/^\d+$/.test(i))return O({},t,r,n,s,[...o,parseInt(i,10)]);const c=P(o);if("set"===i){return O(function(e){return n(o,e),e},t,r,n,s,[...o,i])}if("value"===i)return O(a,t,r,n,s,[...o,i]);if("issues"===i||"allIssues"===i){return O(()=>{const e=s()[""===c?"$":c];return"allIssues"===i?e?.map(e=>({message:e.message})):e?.filter(e=>e.name===c)?.map(e=>({message:e.message}))},t,r,n,s,[...o,i])}if("as"===i){return O((e,t)=>{const r="file multiple"===e||"select multiple"===e||"checkbox"===e&&"string"==typeof t,n={name:("number"===e||"range"===e?"n:":"checkbox"!==e||r?"":"b:")+c+(r?"[]":""),get"aria-invalid"(){const e=s();return c in e?"true":void 0}};return"text"!==e&&"select"!==e&&"select multiple"!==e&&(n.type="file multiple"===e?"file":e),"submit"===e||"hidden"===e?Object.defineProperties(n,{value:{value:t,enumerable:!0}}):"select"===e||"select multiple"===e?Object.defineProperties(n,{multiple:{value:r,enumerable:!0},value:{enumerable:!0,get:()=>a()}}):"checkbox"===e||"radio"===e?Object.defineProperties(n,{value:{value:t??"on",enumerable:!0},checked:{enumerable:!0,get(){const n=a();return"radio"===e?n===t:r?(n??[]).includes(t):n}}}):"file"===e||"file multiple"===e?Object.defineProperties(n,{multiple:{value:r,enumerable:!0},files:{enumerable:!0,get(){const e=a();if(e instanceof File){if("undefined"!=typeof DataTransfer){const t=new DataTransfer;return t.items.add(e),t.files}return{0:e,length:1}}if(Array.isArray(e)&&e.every(e=>e instanceof File)){if("undefined"!=typeof DataTransfer){const t=new DataTransfer;return e.forEach(e=>t.items.add(e)),t.files}const t={length:e.length};return e.forEach((e,r)=>{t[r]=e}),t}return null}}}):Object.defineProperties(n,{value:{enumerable:!0,get(){const e=a();return null!=e?String(e):""}}})},t,r,n,s,[...o,"as"])}return O({},t,r,n,s,[...o,i])}})}function P(e){let t="";for(const r of e)t+="number"==typeof r?`[${r}]`:""===t?r:"."+r;return t}function $(t,r){const n=r??t,s=r&&"unchecked"!==t?t:null;return function t(o){const i={method:"POST"};Object.defineProperty(i,"enhance",{value:()=>({action:i.action,method:i.method})});const a={type:"submit",onclick:()=>{}};Object.defineProperty(a,"enhance",{value:()=>({type:"submit",formaction:i.buttonProps.formaction,onclick:()=>{}})}),Object.defineProperty(i,"buttonProps",{value:a});const c={type:"form",name:"",id:"",fn:async t=>{const o="true"===t.get("sveltekit:validate_only");let i=r?function(e){let t=Object.create(null);for(let r of e.keys()){if(r.startsWith("sveltekit:"))continue;const n=r.endsWith("[]");let s=e.getAll(r);if(n&&(r=r.slice(0,-2)),s.length>1&&!n)throw new Error(`Form cannot contain duplicated keys â€” "${r}" has ${s.length} values`);s=s.filter(e=>"string"==typeof e||""!==e.name||e.size>0),r.startsWith("n:")?(r=r.slice(2),s=s.map(e=>""===e?void 0:parseFloat(e))):r.startsWith("b:")&&(r=r.slice(2),s=s.map(e=>"on"===e)),t=w(t,r,n?s:s[0])}return t}(t):void 0;if(i&&void 0===i.id){const e=t.get("sveltekit:id");"string"==typeof e&&(i.id=JSON.parse(e))}const a={submission:!0},{event:u,state:l}=e(),f=await(s?.["~standard"].validate(i));if(o)return f?.issues??[];if(void 0!==f?.issues)k(a,f.issues,u.isRemoteRequest,t);else{void 0!==f&&(i=f.value),l.refreshes??={};const e=function(){function e(...e){throw new _(e.map(e=>"string"==typeof e?{path:[],message:e}:e))}return new Proxy(e,{get(e,t){if("symbol"==typeof t)return e[t];return E(t,(e,t=[])=>({message:e,path:t}),[])}})}();try{a.result=await h(u,l,!0,i,e=>e,t=>r?n(t,e):n(e))}catch(d){if(!(d instanceof _))throw d;k(a,d.issues,u.isRemoteRequest,t)}}return u.isRemoteRequest||(y(c,l)[""]??=a),a}};return Object.defineProperty(i,"__",{value:c}),Object.defineProperty(i,"action",{get:()=>`?/remote=${c.id}`,enumerable:!0}),Object.defineProperty(a,"formaction",{get:()=>`?/remote=${c.id}`,enumerable:!0}),Object.defineProperty(i,"fields",{get(){const e=y(c)?.[""];return O({},()=>e?.input??{},()=>{},(t,r)=>{if(e?.submission)return;const n=0===t.length?r:j(e?.input??{},t.map(String),r);(y(c)[""]??={}).input=n},()=>e?.issues??{})}}),Object.defineProperty(i,"result",{get(){try{return y(c)?.[""]?.result}catch{return}}}),Object.defineProperty(i,"pending",{get:()=>0}),Object.defineProperty(a,"pending",{get:()=>0}),Object.defineProperty(i,"preflight",{value:()=>i}),Object.defineProperty(i,"validate",{value:()=>{throw new Error("Cannot call validate() on the server")}}),null==o&&Object.defineProperty(i,"for",{value:r=>{const{state:n}=e(),s=c.id+"|"+JSON.stringify(r);let o=(n.form_instances??=new Map).get(s);return o||(o=t(r),o.__.id=`${c.id}/${encodeURIComponent(JSON.stringify(r))}`,o.__.name=c.name,n.form_instances.set(s,o)),o}}),i}()}function k(e,t,r,n){if(e.issues=function(e,t=!1){const r={};for(const n of e){const e={name:"",path:[],message:n.message,server:t};(r.$??=[]).push(e);let s="";if(void 0!==n.path){for(const t of n.path){const n="object"==typeof t?t.key:t;e.path.push(n),"number"==typeof n?s+=`[${n}]`:"string"==typeof n&&(s+=""===s?n:"."+n),(r[s]??=[]).push(e)}e.name=s}}return r}(t),!r){e.input={};for(let t of n.keys()){if(/^[.\]]?_/.test(t))continue;const r=t.endsWith("[]"),s=n.getAll(t).filter(e=>"string"==typeof e);r&&(t=t.slice(0,-2)),e.input=w(e.input,t,r?s:s[0])}}}class _ extends Error{constructor(e){super("Validation failed"),this.name="ValidationError",this.issues=e}}function E(e,t,r){const n=[...r,e];return new Proxy(e=>t(e,n),{get:(e,r)=>"symbol"==typeof r?e[r]:/^\d+$/.test(r)?E(parseInt(r,10),t,n):E(r,t,n)})}function q(t,a,c){const d="function"==typeof a?a:void 0,v=c??(d?void 0:a),g=d??t,w=p(t,d),b={type:"prerender",id:"",name:"",has_arg:!!d,inputs:v?.inputs,dynamic:v?.dynamic},j=t=>{const a=(async()=>{const{event:a,state:c}=e(),d=o(t,c.transport),p=`${l}/${f}/remote/${b.id}${d?`/${d}`:""}`;if(!c.prerendering&&!u&&!a.isRemoteRequest)try{return await m(b,t,c,async()=>{const e=o(t,c.transport),s=y(b,c),i=s[e]??=fetch(new URL(p,a.url.origin).href).then(async e=>{if(!e.ok)throw new Error("Prerendered response not found");const t=await e.json();return"error"===t.type&&n(t.status,t.error),t.result});return function(e,t){const n={};for(const r in t)n[r]=t[r].decode;return r(e,n)}(await i,c.transport)})}catch{}if(c.prerendering?.remote_responses.has(p))return c.prerendering.remote_responses.get(p);const v=m(b,t,c,()=>h(a,c,!1,t,w,g));c.prerendering&&c.prerendering.remote_responses.set(p,v);const j=await v;if(c.prerendering){const e={type:"result",result:i(j,c.transport)};c.prerendering.dependencies.set(p,{body:JSON.stringify(e),response:s(e)})}return j})();return a.catch(()=>{}),a};return Object.defineProperty(j,"__",{value:b}),j}function x(t,r){const n=r??t,s=p(t,r),i={type:"query",id:"",name:""},c=t=>{if(d)throw new Error(`Cannot call query '${i.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:r,state:c}=e(),u=m(i,t,c,()=>h(r,c,!1,t,s,n));return u.catch(()=>{}),u.set=r=>{const{state:n}=e(),s=n.refreshes;if(!s)throw new Error(`Cannot call set on query '${i.name}' because it is not executed in the context of a command/form remote function`);if(i.id){const e=y(i,n),c=o(t,n.transport);s[a(i.id,c)]=e[c]=Promise.resolve(r)}},u.refresh=()=>{const{state:r}=e(),n=r.refreshes;if(!n)throw new Error(`Cannot call refresh on query '${i.name}' because it is not executed in the context of a command/form remote function`);return n[a(i.id,o(t,r.transport))]=u,u.then(()=>{})},u.withOverride=()=>{throw new Error(`Cannot call '${i.name}.withOverride()' on the server`)},u};return Object.defineProperty(c,"__",{value:i}),c}Object.defineProperty(x,"batch",{value:function(t,r){const n=r??t,s=p(t,r),i={type:"query_batch",id:"",name:"",run:t=>{const{event:r,state:o}=e();return h(r,o,!1,t,e=>Promise.all(e.map(s)),n)}};let c={args:[],resolvers:[]};const u=t=>{if(d)throw new Error(`Cannot call query.batch '${i.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:r,state:u}=e(),l=m(i,t,u,()=>new Promise((e,o)=>{c.args.push(t),c.resolvers.push({resolve:e,reject:o}),c.args.length>1||setTimeout(async()=>{const e=c;c={args:[],resolvers:[]};try{const o=await h(r,u,!1,e.args,e=>Promise.all(e.map(s)),n);for(let r=0;r<e.resolvers.length;r++)try{e.resolvers[r].resolve(o(e.args[r],r))}catch(t){e.resolvers[r].reject(t)}}catch(t){for(const r of e.resolvers)r.reject(t)}},0)}));return l.catch(()=>{}),l.refresh=async()=>{const{state:r}=e(),n=r.refreshes;if(!n)throw new Error(`Cannot call refresh on query.batch '${i.name}' because it is not executed in the context of a command/form remote function`);n[a(i.id,o(t,r.transport))]=await l},l.withOverride=()=>{throw new Error(`Cannot call '${i.name}.withOverride()' on the server`)},l};return Object.defineProperty(u,"__",{value:i}),u},enumerable:!0});export{v as command,$ as form,q as prerender,x as query};
